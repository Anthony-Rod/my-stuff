import cv2
import numpy as np
from PIL import Image
import PIL

# Read image
try:
       cap = cv2.VideoCapture("curvedParallelLines/video-24859.MOV")
except Exception:
       print("video could not be found")


arrow = Image.open("curvedParallelLines/arrow3.png").convert("RGBA")
arrow = arrow.rotate(180, PIL.Image.NEAREST, expand=1)
slopes = []
MIN_DISTANCE=50
while True:
       
       ret, frame = cap.read()
       if not ret:
               print("failed to capture frame")
               break

       height, width = frame.shape[:2]
       test = frame[:int(height*0.6), :]
       output = test.copy()
       height1, width1 = test.shape[:2]
       mask = np.zeros_like(output)
       triangle = np.array([[(width1, height1*0.9), (width1*0.5, height1*0.4), (width1*1, height1)]], dtype=np.int32)
       triangle = triangle.reshape((-1, 1, 2))
       cv2.fillPoly(mask, [triangle], (255, 255, 255))
       cv2.polylines = (output, [triangle], True, (255, 0, 0), 3)
       masked_image = cv2.bitwise_and(output, mask)


       """hsv_image = cv2.cvtColor(masked_image, cv2.COLOR_BGR2HSV)
       lower_silver = np.array([0, 0, 0], dtype = np.uint8)
       upper_silver = np.array([180, 50, 200], dtype = np.uint8)
       thresh = cv2.inRange(hsv_image, lower_silver, upper_silver)"""
       gaussian = cv2.blur(masked_image, (3, 3))
       edges = cv2.Canny(gaussian, 25, 75)

       
       lines = cv2.HoughLinesP(
                   edges,
                   2, 
                   np.pi/180,
                   threshold=50, 
                   minLineLength=20, 
                   maxLineGap=50 
                   )
       #cv2.polylines(output, vertices, True, (0, 0, 255), 3)


       left_lane_lines = np.array([])
       right_lane_lines = np.array([])
     
       if lines is not None:
        for points in lines:
            x1, y1, x2, y2 = points[0]
            print(points[0])
            slope = (y2 - y1) / (x2 - x1) if x2 != x1 else 0
            print(slope)
            
            if slope > 0:  
                print("got here")
                right_lane_lines = np.append(right_lane_lines, [(x1, y1), (x2, y2)])

            elif slope < 0:
                print("got here!")
                left_lane_lines = np.append(left_lane_lines, [(x1, y1), (x2, y2)])

       
       if len(left_lane_lines) > 0 and len(right_lane_lines) > 0:

        
        #left lanes
        leftx=np.array([])
        lefty=np.array([])
        #right lanes
        rightx=np.array([])
        righty=np.array([])
        for n in left_lane_lines:
            leftx = np.append(leftx, n[0][0])
            lefty = np.append(lefty, n[0][1])
            leftx = np.append(leftx, n[1][0])
            lefty = np.append(lefty, n[1][1])
        for n in right_lane_lines:
            rightx = np.append(rightx, n[0][0])
            righty = np.append(righty, n[0][1])
            rightx = np.append(rightx, n[1][0])
            righty = np.append(righty, n[1][1])

            
        
        leftLine = np.polyfit(leftx, lefty, 1)
        rightLine = np.polyfit(rightx, righty, 1)
        print(leftLine)
        #formula = y=mx+b | m =_Line[0] b =_Line[1]
        intersectL_bottom = ((height1-leftLine[1])//leftLine[0],height1)
        intersectR_bottom = ((height1-rightLine[1])//rightLine[0],height1)
        intersectL_top = ((-leftLine[1])//((6*height1//5*width1)+leftLine[0]),height1*0.4)
        intersectR_top = ((leftLine[1])//((6*height1//5*width1)-leftLine[0]),height1*0.4)
        cv2.line(output, intersectL_bottom, intersectL_top, (255, 0, 0), 3)
        cv2.line(output, intersectR_bottom, intersectR_top, (255, 0, 0), 3)
        

       cv2.imshow('Detected Lines and Centerline', output)


       if cv2.waitKey(1) & 0xFF == ord('q'):
                break


cap.release()
cv2.destroyAllWindows()
